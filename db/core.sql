-- ===================================================================================
-- 1. CONFIGURACIÓN DEL ENTORNO
-- Definición del esquema 'core' y ajustes iniciales.
-- ===================================================================================

-- Eliminación del esquema existente (solo para desarrollo/pruebas)
DROP SCHEMA IF EXISTS core CASCADE;

-- Creación del esquema principal
CREATE SCHEMA core;

-- Configuración para silenciar advertencias menores
SET client_min_messages TO WARNING;

-- Establecer el esquema de búsqueda
SET search_path TO core;
-- Asignación de propietario (Nota: parametrizar 'cuello_dev' en producción)
ALTER SCHEMA core OWNER TO cuello_dev;


-- ===================================================================================
-- 2. DEFINICIÓN DE TABLAS
-- Diccionario de datos tomado de 'Ing de software.docx' (Estudiante, Acudiente, Docente, etc.)
-- ===================================================================================

-- Tipo de documento (catálogo)
CREATE TABLE IF NOT EXISTS core.tipo_documento
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR(20) NOT NULL,
    abreviatura VARCHAR(2) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.tipo_documento OWNER TO cuello_dev;

-- Rol (usuario)
CREATE TABLE IF NOT EXISTS core.rol
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR(20) NOT NULL UNIQUE,
    descripcion VARCHAR(100),
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.rol OWNER TO cuello_dev;

-- Usuario
CREATE TABLE IF NOT EXISTS core.usuario
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(20) NOT NULL UNIQUE,
    password VARCHAR(100) NOT NULL,
    nombres VARCHAR(50) NOT NULL,
    apellidos VARCHAR(50) NOT NULL,
    id_rol INTEGER NOT NULL, -- FK -> core.rol
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.usuario OWNER TO cuello_dev;

-- Estudiante
CREATE TABLE IF NOT EXISTS core.estudiante
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_tipo_documento INTEGER NOT NULL, -- FK -> core.tipo_documento
    id_acudiente INTEGER,                -- FK -> core.acudiente (nullable: un estudiante puede agregarse sin acudiente inicialmente)
    numero_documento VARCHAR(10) NOT NULL,
    genero VARCHAR(20) NOT NULL,
    nombres VARCHAR(50) NOT NULL,
    apellidos VARCHAR(50) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
)
TABLESPACE pg_default;
ALTER TABLE core.estudiante OWNER TO cuello_dev;

-- Acudiente
CREATE TABLE IF NOT EXISTS core.acudiente
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_tipo_documento INTEGER NOT NULL, -- FK -> core.tipo_documento
    numero_documento VARCHAR(10) NOT NULL,
    genero VARCHAR(20) NOT NULL,
    nombres VARCHAR(50) NOT NULL,
    apellidos VARCHAR(50) NOT NULL,
    telefono VARCHAR(15),
    correo VARCHAR(30),
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
)
TABLESPACE pg_default;
ALTER TABLE core.acudiente OWNER TO cuello_dev;

-- Tabla intermedia Acudiente <-> Estudiante (vínculo con parentesco)
CREATE TABLE IF NOT EXISTS core.acudiente_estudiante
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_acudiente INTEGER NOT NULL, -- FK -> core.acudiente
    id_estudiante INTEGER NOT NULL, -- FK -> core.estudiante
    parentesco VARCHAR(30),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (id_acudiente, id_estudiante)
)
TABLESPACE pg_default;
ALTER TABLE core.acudiente_estudiante OWNER TO cuello_dev;

-- Docente
CREATE TABLE IF NOT EXISTS core.docente
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_usuario INTEGER,               -- FK -> core.usuario (opcional según doc)
    id_tipo_documento INTEGER NOT NULL,
    numero_documento VARCHAR(10) NOT NULL,
    nombres VARCHAR(50) NOT NULL,
    apellidos VARCHAR(50) NOT NULL,
    telefono VARCHAR(15),
    correo VARCHAR(50),
    fecha_nacimiento DATE,
    genero VARCHAR(20),
    fecha_contratacion DATE NOT NULL,
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.docente OWNER TO cuello_dev;

-- Area
CREATE TABLE IF NOT EXISTS core.area
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR(50) NOT NULL,
    descripcion VARCHAR(50),
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.area OWNER TO cuello_dev;

-- Asignatura
CREATE TABLE IF NOT EXISTS core.asignatura
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_area INTEGER NOT NULL, -- FK -> core.area
    nombre VARCHAR(50) NOT NULL,
    codigo VARCHAR(20) NOT NULL,
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.asignatura OWNER TO cuello_dev;

-- Docente_Asignatura (asignaciones directas)
CREATE TABLE IF NOT EXISTS core.docente_asignatura
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_docente INTEGER NOT NULL,    -- FK -> core.docente
    id_asignatura INTEGER NOT NULL, -- FK -> core.asignatura
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (id_docente, id_asignatura)
)
TABLESPACE pg_default;
ALTER TABLE core.docente_asignatura OWNER TO cuello_dev;

-- Grado
CREATE TABLE IF NOT EXISTS core.grado
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR(20) NOT NULL,
    nivel VARCHAR(20) NOT NULL,
    descripcion VARCHAR(50),
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.grado OWNER TO cuello_dev;

-- Grupo (Curso / Sección)
CREATE TABLE IF NOT EXISTS core.grupo
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_grado INTEGER NOT NULL, -- FK -> core.grado
    codigo VARCHAR(5) NOT NULL,
    anio_lectivo VARCHAR(10) NOT NULL,
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.grupo OWNER TO cuello_dev;

-- Grado_Asignatura (relación grado-asignatura, con docente responsable opcional)
CREATE TABLE IF NOT EXISTS core.grado_asignatura
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_grado INTEGER NOT NULL,       -- FK -> core.grado
    id_asignatura INTEGER NOT NULL,  -- FK -> core.asignatura
    id_docente INTEGER,              -- FK -> core.docente (opcional)
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (id_grado, id_asignatura)
)
TABLESPACE pg_default;
ALTER TABLE core.grado_asignatura OWNER TO cuello_dev;

-- Matrícula
CREATE TABLE IF NOT EXISTS core.matricula
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_estudiante INTEGER NOT NULL, -- FK -> core.estudiante
    id_grupo INTEGER NOT NULL,      -- FK -> core.grupo
    periodo VARCHAR(10) NOT NULL,
    fecha_registro DATE NOT NULL DEFAULT CURRENT_DATE,
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.matricula OWNER TO cuello_dev;

-- Evaluación
CREATE TABLE IF NOT EXISTS core.evaluacion
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_grado_asignatura INTEGER NOT NULL, -- FK -> core.grado_asignatura
    tipo VARCHAR(50) NOT NULL,
    fecha DATE NOT NULL,
    descripcion TEXT,
    porcentaje DECIMAL(5,2) NOT NULL,
    estado BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.evaluacion OWNER TO cuello_dev;

-- Calificación
CREATE TABLE IF NOT EXISTS core.calificacion
(
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_estudiante INTEGER NOT NULL,   -- FK -> core.estudiante
    id_evaluacion INTEGER NOT NULL,   -- FK -> core.evaluacion
    valor NUMERIC(4,2) NOT NULL,      -- rango 0.00 - 5.00 (se valida más abajo)
    fecha_registro DATE NOT NULL DEFAULT CURRENT_DATE,
    observaciones TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
)
TABLESPACE pg_default;
ALTER TABLE core.calificacion OWNER TO cuello_dev;

-- ===================================================================================
-- 4. DEFINICIÓN DE CLAVES FORÁNEAS (FK)
-- Reglas de integridad referencial (se usan nombres claros y DROP previo de constraints)
-- ===================================================================================

-- tipo_documento relations
ALTER TABLE core.estudiante DROP CONSTRAINT IF EXISTS estudiante_id_tipo_documento_fkey;
ALTER TABLE core.estudiante ADD CONSTRAINT estudiante_id_tipo_documento_fkey FOREIGN KEY (id_tipo_documento)
    REFERENCES core.tipo_documento (id) ON DELETE RESTRICT;

ALTER TABLE core.acudiente DROP CONSTRAINT IF EXISTS acudiente_id_tipo_documento_fkey;
ALTER TABLE core.acudiente ADD CONSTRAINT acudiente_id_tipo_documento_fkey FOREIGN KEY (id_tipo_documento)
    REFERENCES core.tipo_documento (id) ON DELETE RESTRICT;

ALTER TABLE core.docente DROP CONSTRAINT IF EXISTS docente_id_tipo_documento_fkey;
ALTER TABLE core.docente ADD CONSTRAINT docente_id_tipo_documento_fkey FOREIGN KEY (id_tipo_documento)
    REFERENCES core.tipo_documento (id) ON DELETE RESTRICT;

-- usuario -> rol
ALTER TABLE core.usuario DROP CONSTRAINT IF EXISTS usuario_id_rol_fkey;
ALTER TABLE core.usuario ADD CONSTRAINT usuario_id_rol_fkey FOREIGN KEY (id_rol)
    REFERENCES core.rol (id) ON DELETE RESTRICT;

-- docente -> usuario (opcional)
ALTER TABLE core.docente DROP CONSTRAINT IF EXISTS docente_id_usuario_fkey;
ALTER TABLE core.docente ADD CONSTRAINT docente_id_usuario_fkey FOREIGN KEY (id_usuario)
    REFERENCES core.usuario (id) ON DELETE SET NULL;

-- estudiante -> acudiente (vía id_acudiente)
ALTER TABLE core.estudiante DROP CONSTRAINT IF EXISTS estudiante_id_acudiente_fkey;
ALTER TABLE core.estudiante ADD CONSTRAINT estudiante_id_acudiente_fkey FOREIGN KEY (id_acudiente)
    REFERENCES core.acudiente (id) ON DELETE SET NULL;

-- acudiente_estudiante relations
ALTER TABLE core.acudiente_estudiante DROP CONSTRAINT IF EXISTS acudiente_estudiante_id_acudiente_fkey;
ALTER TABLE core.acudiente_estudiante ADD CONSTRAINT acudiente_estudiante_id_acudiente_fkey FOREIGN KEY (id_acudiente)
    REFERENCES core.acudiente (id) ON DELETE CASCADE;

ALTER TABLE core.acudiente_estudiante DROP CONSTRAINT IF EXISTS acudiente_estudiante_id_estudiante_fkey;
ALTER TABLE core.acudiente_estudiante ADD CONSTRAINT acudiente_estudiante_id_estudiante_fkey FOREIGN KEY (id_estudiante)
    REFERENCES core.estudiante (id) ON DELETE CASCADE;

-- docente_asignatura relations
ALTER TABLE core.docente_asignatura DROP CONSTRAINT IF EXISTS docente_asignatura_id_docente_fkey;
ALTER TABLE core.docente_asignatura ADD CONSTRAINT docente_asignatura_id_docente_fkey FOREIGN KEY (id_docente)
    REFERENCES core.docente (id) ON DELETE CASCADE;

ALTER TABLE core.docente_asignatura DROP CONSTRAINT IF EXISTS docente_asignatura_id_asignatura_fkey;
ALTER TABLE core.docente_asignatura ADD CONSTRAINT docente_asignatura_id_asignatura_fkey FOREIGN KEY (id_asignatura)
    REFERENCES core.asignatura (id) ON DELETE CASCADE;

-- grado_asignatura relations
ALTER TABLE core.grado_asignatura DROP CONSTRAINT IF EXISTS grado_asignatura_id_grado_fkey;
ALTER TABLE core.grado_asignatura ADD CONSTRAINT grado_asignatura_id_grado_fkey FOREIGN KEY (id_grado)
    REFERENCES core.grado (id) ON DELETE CASCADE;

ALTER TABLE core.grado_asignatura DROP CONSTRAINT IF EXISTS grado_asignatura_id_asignatura_fkey;
ALTER TABLE core.grado_asignatura ADD CONSTRAINT grado_asignatura_id_asignatura_fkey FOREIGN KEY (id_asignatura)
    REFERENCES core.asignatura (id) ON DELETE CASCADE;

ALTER TABLE core.grado_asignatura DROP CONSTRAINT IF EXISTS grado_asignatura_id_docente_fkey;
ALTER TABLE core.grado_asignatura ADD CONSTRAINT grado_asignatura_id_docente_fkey FOREIGN KEY (id_docente)
    REFERENCES core.docente (id) ON DELETE SET NULL;

-- grupo -> grado
ALTER TABLE core.grupo DROP CONSTRAINT IF EXISTS grupo_id_grado_fkey;
ALTER TABLE core.grupo ADD CONSTRAINT grupo_id_grado_fkey FOREIGN KEY (id_grado)
    REFERENCES core.grado (id) ON DELETE RESTRICT;

-- matricula relations
ALTER TABLE core.matricula DROP CONSTRAINT IF EXISTS matricula_id_estudiante_fkey;
ALTER TABLE core.matricula ADD CONSTRAINT matricula_id_estudiante_fkey FOREIGN KEY (id_estudiante)
    REFERENCES core.estudiante (id) ON DELETE CASCADE;

ALTER TABLE core.matricula DROP CONSTRAINT IF EXISTS matricula_id_grupo_fkey;
ALTER TABLE core.matricula ADD CONSTRAINT matricula_id_grupo_fkey FOREIGN KEY (id_grupo)
    REFERENCES core.grupo (id) ON DELETE CASCADE;

-- evaluacion relations
ALTER TABLE core.evaluacion DROP CONSTRAINT IF EXISTS evaluacion_id_grado_asignatura_fkey;
ALTER TABLE core.evaluacion ADD CONSTRAINT evaluacion_id_grado_asignatura_fkey FOREIGN KEY (id_grado_asignatura)
    REFERENCES core.grado_asignatura (id) ON DELETE CASCADE;

-- calificacion relations
ALTER TABLE core.calificacion DROP CONSTRAINT IF EXISTS calificacion_id_estudiante_fkey;
ALTER TABLE core.calificacion ADD CONSTRAINT calificacion_id_estudiante_fkey FOREIGN KEY (id_estudiante)
    REFERENCES core.estudiante (id) ON DELETE CASCADE;

ALTER TABLE core.calificacion DROP CONSTRAINT IF EXISTS calificacion_id_evaluacion_fkey;
ALTER TABLE core.calificacion ADD CONSTRAINT calificacion_id_evaluacion_fkey FOREIGN KEY (id_evaluacion)
    REFERENCES core.evaluacion (id) ON DELETE CASCADE;


-- ===================================================================================
-- 5. FUNCIONES Y TRIGGERS AUTOMÁTICOS
-- Lógica para updated_at y validaciones sencillas.
-- ===================================================================================

-- Función genérica para actualizar 'updated_at' en cada UPDATE
DROP FUNCTION IF EXISTS core.set_updated_at_timestamp() CASCADE;
CREATE OR REPLACE FUNCTION core.set_updated_at_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGERS de 'updated_at' para tablas relevantes
DROP TRIGGER IF EXISTS trg_set_tipo_documento_updated_at ON core.tipo_documento;
CREATE TRIGGER trg_set_tipo_documento_updated_at BEFORE UPDATE ON core.tipo_documento FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

DROP TRIGGER IF EXISTS trg_set_usuario_updated_at ON core.usuario;
CREATE TRIGGER trg_set_usuario_updated_at BEFORE UPDATE ON core.usuario FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

DROP TRIGGER IF EXISTS trg_set_estudiante_updated_at ON core.estudiante;
CREATE TRIGGER trg_set_estudiante_updated_at BEFORE UPDATE ON core.estudiante FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

DROP TRIGGER IF EXISTS trg_set_acudiente_updated_at ON core.acudiente;
CREATE TRIGGER trg_set_acudiente_updated_at BEFORE UPDATE ON core.acudiente FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

DROP TRIGGER IF EXISTS trg_set_docente_updated_at ON core.docente;
CREATE TRIGGER trg_set_docente_updated_at BEFORE UPDATE ON core.docente FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

DROP TRIGGER IF EXISTS trg_set_asignatura_updated_at ON core.asignatura;
CREATE TRIGGER trg_set_asignatura_updated_at BEFORE UPDATE ON core.asignatura FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

DROP TRIGGER IF EXISTS trg_set_grado_updated_at ON core.grado;
CREATE TRIGGER trg_set_grado_updated_at BEFORE UPDATE ON core.grado FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

DROP TRIGGER IF EXISTS trg_set_grupo_updated_at ON core.grupo;
CREATE TRIGGER trg_set_grupo_updated_at BEFORE UPDATE ON core.grupo FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

DROP TRIGGER IF EXISTS trg_set_matricula_updated_at ON core.matricula;
CREATE TRIGGER trg_set_matricula_updated_at BEFORE UPDATE ON core.matricula FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

DROP TRIGGER IF EXISTS trg_set_evaluacion_updated_at ON core.evaluacion;
CREATE TRIGGER trg_set_evaluacion_updated_at BEFORE UPDATE ON core.evaluacion FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

DROP TRIGGER IF EXISTS trg_set_calificacion_updated_at ON core.calificacion;
CREATE TRIGGER trg_set_calificacion_updated_at BEFORE UPDATE ON core.calificacion FOR EACH ROW EXECUTE FUNCTION core.set_updated_at_timestamp();

-- Validación de rango para calificaciones (0.00 - 5.00)
ALTER TABLE core.calificacion DROP CONSTRAINT IF EXISTS chk_calificacion_valor;
ALTER TABLE core.calificacion ADD CONSTRAINT chk_calificacion_valor CHECK (valor >= 0 AND valor <= 5);

-- Trigger para evitar duplicados de matrícula por estudiante/grupo/periodo
DROP FUNCTION IF EXISTS core.prevent_duplicate_matricula() CASCADE;
CREATE OR REPLACE FUNCTION core.prevent_duplicate_matricula()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM core.matricula m
        WHERE m.id_estudiante = NEW.id_estudiante
          AND m.id_grupo = NEW.id_grupo
          AND m.periodo = NEW.periodo
          AND (NEW.id IS NULL OR m.id <> NEW.id)
    ) THEN
        RAISE EXCEPTION 'El estudiante ya tiene matrícula en ese grupo y periodo.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_prevent_duplicate_matricula ON core.matricula;
CREATE TRIGGER trg_prevent_duplicate_matricula
BEFORE INSERT OR UPDATE ON core.matricula
FOR EACH ROW EXECUTE FUNCTION core.prevent_duplicate_matricula();

-- ===================================================================================
-- 6. CREACIÓN DE ÍNDICES
-- Optimización de rendimiento para búsquedas, unicidad y JSONB.
-- ===================================================================================

-- Índice Único para username (case-insensitive)
CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_usuario_username_ci ON core.usuario (LOWER(username));

-- Índices únicos parciales para evitar duplicados de documento en entidades activas
CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_estudiante_documento_active
    ON core.estudiante (numero_documento)
    WHERE estado IS TRUE;

CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_acudiente_documento_active
    ON core.acudiente (numero_documento)
    WHERE estado IS TRUE;

-- Índices para FK y búsquedas frecuentes
CREATE INDEX IF NOT EXISTS idx_estudiante_id_tipo_documento ON core.estudiante (id_tipo_documento);
CREATE INDEX IF NOT EXISTS idx_estudiante_id_acudiente ON core.estudiante (id_acudiente);
CREATE INDEX IF NOT EXISTS idx_acudiente_id_tipo_documento ON core.acudiente (id_tipo_documento);
CREATE INDEX IF NOT EXISTS idx_docente_id_usuario ON core.docente (id_usuario);
CREATE INDEX IF NOT EXISTS idx_docente_num_documento ON core.docente (numero_documento);
CREATE INDEX IF NOT EXISTS idx_matricula_id_estudiante ON core.matricula (id_estudiante);
CREATE INDEX IF NOT EXISTS idx_matricula_id_grupo ON core.matricula (id_grupo);
CREATE INDEX IF NOT EXISTS idx_calificacion_id_estudiante ON core.calificacion (id_estudiante);
CREATE INDEX IF NOT EXISTS idx_calificacion_id_evaluacion ON core.calificacion (id_evaluacion);
CREATE INDEX IF NOT EXISTS idx_evaluacion_id_grado_asignatura ON core.evaluacion (id_grado_asignatura);

-- Índices para reportes: búsquedas por año/periodo/curso
CREATE INDEX IF NOT EXISTS idx_grupo_anio_lectivo ON core.grupo (anio_lectivo);
CREATE INDEX IF NOT EXISTS idx_matricula_periodo ON core.matricula (periodo);

-- ===================================================================================
-- FIN DEL SCRIPT
-- ===================================================================================
